---
title: "Ray Tracing Basics"
date: 2021-03-22T17:08:16-03:00
draft: false
---

Yesterday I finished some React challenges from the bootcamp I'm doing.
I also learned about `Bounding volume hierarchy` and `The Rendering Equation`.

A `Bounding volume hierarchy` is a tree structure that
delimits the objects we need to render in a scene.
Each node in this tree is either an object that we might have to render,
or a virtual object that contains more than one object.

If we cast a ray and we hit a node in the tree
we know we only have to care about the object below that node,
and reduce the amount of objects we need to check.
It's a basic optimization that drastically increases performance
as the scenes have more objects
and as the objects become more complex (with different textures and polygons).

The `Rendering Equation` is a simple but complete model
of how ray-tracing works:

<img src="https://latex.codecogs.com/svg.latex?\Large&space;{\displaystyle L_{\text{o}}(\mathbf {x} ,\omega _{\text{o}},\lambda ,t)=L_{\text{e}}(\mathbf {x} ,\omega _{\text{o}},\lambda ,t)\ +\int _{\Omega }f_{\text{r}}(\mathbf {x} ,\omega _{\text{i}},\omega _{\text{o}},\lambda ,t)L_{\text{i}}(\mathbf {x} ,\omega _{\text{i}},\lambda ,t)(\omega _{\text{i}}\cdot \mathbf {n} )\operatorname {d} \omega _{\text{i}}}" title="\Large {\displaystyle L_{\text{o}}(\mathbf {x} ,\omega _{\text{o}},\lambda ,t)=L_{\text{e}}(\mathbf {x} ,\omega _{\text{o}},\lambda ,t)\ +\int _{\Omega }f_{\text{r}}(\mathbf {x} ,\omega _{\text{i}},\omega _{\text{o}},\lambda ,t)L_{\text{i}}(\mathbf {x} ,\omega _{\text{i}},\lambda ,t)(\omega _{\text{i}}\cdot \mathbf {n} )\operatorname {d} \omega _{\text{i}}}" />

The term on the left
<img src="https://latex.codecogs.com/svg.latex?\Large&space;{\displaystyle L_{\text{o}}(\mathbf {x} ,\omega _{\text{o}},\lambda ,t)}" title="\Large {\displaystyle L_{\text{o}}(\mathbf {x} ,\omega _{\text{o}},\lambda ,t)}" />
represent the `spectral radiance` of an arbitrary ray we cast.
In computer terms the spectral radiance is pretty much the `rgba`,
the hue we calculate for the ray.
The aim of a ray-tracing engine is to solve for this hue
for each pixel on a canvas/screen.

The first term on the right
<img src="https://latex.codecogs.com/svg.latex?\Large&space;{\displaystyle L_{\text{e}}(\mathbf {x} ,\omega _{\text{o}},\lambda ,t)}" title="\Large {\displaystyle L_{\text{e}}(\mathbf {x} ,\omega _{\text{o}},\lambda ,t)}" />
is called the `emitted spectral radiance`, which is basically the ambient light.

The second term on the right
<img src="https://latex.codecogs.com/svg.latex?\Large&space;{\displaystyle \int _{\Omega }\dots \operatorname {d} \omega _{\text{i}}}" title="\Large {\displaystyle \int _{\Omega }\dots \operatorname {d} \omega _{\text{i}}}" />
represent the the entire interaction between the ray
and the surface it's trying to render.
There's a lot of interesting physical phenomena that this term takes into account:

- the incidence of the ray with the normal of the surface at the point of intersection
  <img src="https://latex.codecogs.com/svg.latex?\Large&space;\omega _{{{\text{i}}}}\cdot {\mathbf n}" title="\Large \omega _{{{\text{i}}}}\cdot {\mathbf n}" />
  , which reduces the overall radiance as the angle increases.
- the amount of light reflected back to origin of the ray at the point of intersection
  <img src="https://latex.codecogs.com/svg.latex?\Large&space;{\displaystyle L_{\text{i}}(\mathbf {x} ,\omega _{\text{i}},\lambda ,t)}" title="\Large {\displaystyle L_{\text{i}}(\mathbf {x} ,\omega _{\text{i}},\lambda ,t)}" />
  , which in itself is another ray-tracing problem.
  There's usually a lot of recursion and parallelism in ray-tracing engines.
- the `bidirectional reflectance distribution function`
  <img src="https://latex.codecogs.com/svg.latex?\Large&space;{\displaystyle f_{\text{r}}(\mathbf {x} ,\omega _{\text{i}},\omega _{\text{o}},\lambda ,t)}" title="\Large {\displaystyle f_{\text{r}}(\mathbf {x} ,\omega _{\text{i}},\omega _{\text{o}},\lambda ,t)}" />
  , is basically how we account for light effects on different surfaces:
  glossy, mirror reflections, matte/not glossy, and others.

Today I'm gonna do some Node and Elixir Challenges from my bootcamp.
I wanna get those out of the way quickly and start focusing on the Ray Tracer.

### References:

- https://en.wikipedia.org/wiki/Bounding_volume_hierarchy
- https://www.youtube.com/watch?v=AODo_RjJoUA
- https://en.wikipedia.org/wiki/Rendering_equation
- https://en.wikipedia.org/wiki/Bidirectional_reflectance_distribution_function
